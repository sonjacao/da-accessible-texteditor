\chapter{Ausgewählte Technologien}
% languages, libraries, IDEs and tools
\section{Git und GitLab}

\subsection{Versionskontrollsystem}
Oftmals arbeitet ein Entwickler oder ein Entwicklerteam an einem Softwareprojekt, um entweder Fehler zu beheben oder neue Funktionalitäten hinzuzufügen. Hierbei werden Änderungen am Quellcode durchgeführt, die regelmäßig gesichert werden müssen. Diese Änderungen können in manchen Fällen auch dazu führen, dass etwas anderes im Code nicht mehr so funktioniert wie es sollte. Dann werden weitere Änderungen gemacht, um wieder einen lauffähigen Stand herzustellen, jedoch kann es passieren, dass plötzlich gar nichts mehr funktioniert.

\mbox{}\\Abhilfe für dieses Problem bietet ein Versionskontrollsystem, auch als VCS (Version Control System, vlg. \cite{vcs_2019}) bezeichnet, das Änderungen in der Projektentwicklung festhält. Dadurch ist es möglich zu einem späteren beliebigen Zeitpunkt auf ältere Versionen des Systems zurückzugreifen, den aktuellen Code mit früheren Versionen zu vergleichen oder Bugfixes zu implementieren. Arbeiten mehrere Entwickler an denselben Dateien im Quellcode, so kann mitverfolgt werden, welche Person welche Änderungen gemacht hat. Ein Projekt, das mit einem VCS verwaltet wird, heißt Repository. Ein Repository kann als eine Art Datenbank mit allen Änderungen betrachtet werden, die die History repräsentieren. Diese Änderungen sind ein markierter Stand, ein sogenannter Commit, in der Projektentwicklung und werden als Working Copy gespeichert, die einer Kopie des gesamten Projektes entspricht. Ein Commit kann als Schnappschuss oder als kleiner Meilenstein betrachtet werden. Er beinhaltet neben der Working Copy einen Zeitstempel und eine Nachricht, die aussagt, was sich seit dem letzten Commit geändert hat. Die Entwicklungsarbeiten können dabei in mehreren Entwicklungszweigen (engl. Branches) erfolgen. Eine Abspaltung eines Projektes wird hingegen als Fork bezeichnet.

\mbox{}\\Es gibt drei Arten von Version Control Systems:

\begin{itemize}
	\item \textbf{Lokal:} Lokale Versionskontrollsysteme funktionieren nur auf einem Rechner und versionieren eine einzige Datei. Insbesondere in Büroanwendungen kommen Tools wie Revision Control System (RCS) oder Source Code Control System (SCCS) zum Einsatz. Das Dokument speichert  dabei jede Version in seiner eigenen Datei.
	
	\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.65]{images/local_vcs.png}
	\end{center}
		\caption{Lokales Versionskontrollsystem}
	\end{figure}
	
	\item \textbf{Zentral:} Bei einem zentralisierten Versionskontrollsystem gibt es ein Respository, das sich mehrere 		Entwickler in einem Netzwerk miteinander teilen. Es handelt sich hierbei um ein Client-Server-System, das 		von zahlreichen kommerziellen Anbietern verwendet wird. Durch das Concurrent Versions System (CVS) 			wurde dieses Konzept berühmt, aber durch Subversion (SVN) neu implementiert.
	
	\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.65]{images/central_vcs.png}
	\end{center}
		\caption{Zentralisiertes Versionskontrollsystem}
	\end{figure}
	
	\item \textbf{Verteiltes VCS:} Im Gegensatz zum zentralisierten VCS existiert beim verteilten Versionskontrollsystem 		kein zentrales Repository. Jeder am Projekt tätige Entwickler verfügt über ein eigenes Repository, das er mit 		anderen Repositories abgleichen kann. Auch hier ist die History klar ersichtlich. Der einzige Unterschied zu 		den beiden anderen Versionskontrollsystemen ist der, dass Änderungen hier am lokalen Rechner erfolgen 		können. Eine Verbindung mit dem Server ist nicht notwendig.
	
	\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{images/distributed_vcs.png}
	\end{center}
		\caption{Verteiltes Versionskontrollsystem}
	\end{figure}
\end{itemize}

\subsection{Git}
Git \cite{git_2020} ist ein Open-Source-Tool von Linus Torvalds, dem Entwickler des Betriebssystems Linux, aus dem Jahr 2005. Heutzutage zählt es zu eines der weitverbreitesten Versionsverwaltungssysteme weltweit. Die Softwareentwickler kommen sowohl aus dem kommerziellen als auch aus dem öffentlichen Bereich. Aufgrund seiner Architektur ist Git ein Distributed VCS (DVCS, dt. verteiltes VCS) und funktioniert in zahlreichen Plattformen und Entwicklungsumgebungen. Das bedeutet, dass auf die gesamte History mit allen Entwicklungsarbeiten von jedem Standort aus zugegriffen werden kann. Neben seinem verteilten System ist Git unter anderem auf Performance, Sicherheit und Flexibilität fokussiert.

\paragraph{Snapshots}\mbox{}\\
Bei den meisten VCS werden Informationen als eine Liste mit den Änderungen innerhalb der Dateien gespeichert. Das bedeutet, dass bei jeder Version nur die Dateien festgehalten werden, deren Inhalt sich während den Entwicklungsarbeiten geändert haben.

\begin{figure}[H]
\begin{center}
	\includegraphics[scale=.4]{images/other_vcs.png}
\end{center}
	\caption{Speichern von Daten bei anderen VCS}
\end{figure} 

\mbox{}\\Im Gegensatz dazu werden die Daten als eine Art Folge von Schnappschüssen (engl. snapshots) betrachtet. Nach jedem Commit wird der aktuelle Stand des Repositories gespeichert. Dieser beinhaltet die gesamte Kopie des Projekts zu diesem Zeitpunkt und erhält eine Referenz zu diesem Schnappschuss in Form eines einzigartigen Hashwertes. Wenn das Entwicklerteam weiter am Projekt arbeitet und die Änderungen committet, erhalten die neuen und geänderten Dateien eine neuen Hashwert, während die Dateien, die sich nicht geändert haben, nur auf dieselbe Datei im vorherigen Schnappschuss verlinkt werden.

\begin{figure}[H]
\begin{center}
	\includegraphics[scale=.4]{images/git_snapshot.png}
\end{center}
	\caption{Speichern von Daten bei Git}
\end{figure}

\mbox{}\\Um eine Sicherheit garantieren zu können, werden die Dateiinhalte sowie ihre Beziehungen zu anderen Dateien, Verzeichnissen, Versionen, Commits und Tags mit dem Hashing-Algorithmus SHA1 gesichert. Dadurch kann der Quellcode des Entwicklers vor ungewollten Änderungen geschützt und die Historie vollständig mitverfolgt werden. In der Datenbank werden keine Dateinamen sondern nur Hashwerte gespeichert. Ein Beispiel für so einen Wert ist \texttt{fe215ed7198155ca796fbb8ef81683137c210492}.\\

\paragraph{Workflow}\mbox{}\\
In einem Git-Projekt sind die drei wichtigsten Stufen das Working Directory, die Staging Area und das Repository, wobei dieses in das \texttt{local} und das  \texttt{remote} Repository gegliedert werden kann. Mit  \texttt{add} wird eine Kopie des Working Directory erstellt, wobei die Änderungen an den Dateien mit  \texttt{new},  \texttt{modified} oder  \texttt{deleted} gekennzeichnet sind. Die Arbeitskopie befindet sich nun in der Staging Area und noch nicht in der Datenbank. Nun haben die Dateien den Status  \texttt{staged} und können im nächsten Schnappschuss eingepflegt werden. Nach einem  \texttt{commit} wird ein Schnappschuss im lokalen Repository erstellt, der mit einem  \texttt{push} in der Datenbank und somit im entfernten Repository gesichert wird.

\begin{figure}[H]
\begin{center}
	\includegraphics[scale=.3]{images/git_workflow.png}
\end{center}
	\caption{Die drei Hauptstufen von Git}
\end{figure}

\paragraph{Merge}\mbox{}\\
Oftmals Entwicklungszweige erstellt um Bugs zu beheben oder an neuen Funktionalitäten einer Software zu arbeiten. Diese Änderungen sollen zu einem späteren Zeitpunkt in einen einzigen Branch integriert werden, der in den meisten Fällen der Hauptzweig \texttt{master} ist. Dies wird durch einen Merge ermöglicht.

 \mbox{}\\
Mehrere Commits aus zwei Entwicklungszweigen werden in einen einheitlichen Verlauf zusammengeführt und die Branches somit vereint. Im Prinzip sucht sich der Pointer der Commits einen gemeinsamen Commit als Basis des Merges. Genau dann, wenn diese Basis gefunden wird, wird ein zusätzlicher Commit für den Merge erstellt. Dadurch werden alle seither vorgenommenen Änderungen in einen gemeinsamen Verlauf vereint.

\begin{figure}[H]
\begin{center}
	\includegraphics[scale=.8]{images/git-merge.png}
\end{center}
	\caption{Mergen von zwei Branches mit Merge-Commit}
\end{figure}

 \mbox{}\\
Im Gegensatz zu einfachen Commits während der Entwicklung, haben Merge-Commits zwei übergeordnete Commits. Sind Änderungen in beiden Branches vorgenommen worden, können von Git nicht automatisch zusammengeführt werden. Dies führt oftmals zu einem Versionskontrollkonflikt, der von dem Entwickler manuell beseitigt werden muss. Im Normalfall kann Git die Commit-Historie automatischen zusammenführen, es sei denn es gibt Änderen im aktuellen Branch und im Ziel-Branch, die zu Konflikten im Projekt führen.

 \mbox{}\\
Grundsätzlich gibt es zwei Arten von Merges:

\begin{itemize}
	\item \textbf{Fast-Forward-Merge:}\\
		Wenn der Verlauf vom aktuellen Entwicklungszweig zum Ziel-Branch linear ist, findet ein Fast-Forward-Merge
		statt. Linear bedeutet, dass nur an einem Entwicklungszweig Änderungen vorgenommen worden sind und der 
		andere genauso geblieben ist, wie zu dem Zeitpunkt, an dem der andere Branch erstellt worden ist.\\
		Bei diesem Merge wird ausschließlich der Pointer des Ziel-Branches auf die Commit-Spitze des aktuellen 
		Branches gelegt. Somit werden die beiden Entwicklungszweige kombiniert und enthalten dieselbe 
		Commit-Historie. Da lediglich die Position des Pointers verändert wird, erstellt Git keinen Merge-Commit. 
		Für den Fall, dass kein linearer Pfad zum Ziel-Branch existiert, erfolgt das Zusammenführen der Branches
		mit einem 3-Way-Merge. 
		
		\begin{figure}[H]
		\begin{center}
			\includegraphics[scale=.8]{images/git-fast-forward-merge-before.png}
		\end{center}
			\caption{Es werden Änderungen am \texttt{feature}-Branch vorgenommen, der \texttt{master}-Branch
				bleibt gleich.}
		\end{figure}
		
		\begin{figure}[H]
		\begin{center}
			\includegraphics[scale=.8]{images/git-fast-forward-merge-after.png}
		\end{center}
			\caption{Die Änderungen des \texttt{feature}-Branches werden in den \texttt{master}-Branch eingepflegt.}
		\end{figure}
		
	\item \textbf{3-Way-Merge:}\\
		Die Bezeichnung 3-Way-Merge kommt daher, dass für das Zusammenführen von zwei Entwicklungszweigen 
		drei Commits benötigt werden. Zwei Commits sind die Spitzen der beiden Branches und ein Commit ist ihr
		gemeinsamer Basis-Commit.\\
		Hierbei werden seit der Erstellung eines neuen Entwicklungszweiges sowohl 
		am Ziel-Branch als auch am aktuellen Branch neue Änderungen gemacht, die wieder zusammengeführt
		werden sollen. Vor allem beim Entwickeln neuer umfangreicher Funktionalitäten oder beim zeitgleichen 
		Arbeiten mehrere Entwickler an demselben Projekt, ist ein 3-Way-Merge erforderlich. \\
		Allerdings kann es hierbei zu Konflikten während eines Merges kommen, die von dem Entwickler selbst
		gelöst werden muss.
		
		\begin{figure}[H]
		\begin{center}
			\includegraphics[scale=.8]{images/git-3-way-merge-before.png}
		\end{center}
			\caption{Es werden Änderungen am \texttt{feature}-Branch am \texttt{master}-Branch vorgenommen.}
		\end{figure}
		
		\begin{figure}[H]
		\begin{center}
			\includegraphics[scale=.8]{images/git-3-way-merge-after.png}
		\end{center}
			\caption{Die Änderungen des \texttt{feature}-Branches werden mit einem Merge-Commit in den 
				\texttt{master}-Branch eingepflegt.}
		\end{figure}
\end{itemize}

\subsection{GitLab}
Im Jahr 2011 wurde GitLab \cite{gitlab_2020} von den ukrainischen Entwicklern Dmitri Saparoschez und Valery Sizov ursprünglich in der Programmiersprache Ruby on Rails und mittlerweile noch zusätzlich in Go und Vue.js geschrieben. Es ist eine Webapplikation zur Versionskontrolle, das auf Git basiert. Neben dem Arbeiten mit Git stellt diese Anwendung einige weitere Funktionen zur Verfügung. Diese sind beispielsweise eine integrierte und kostenlose Continuous Integration/Delivery (CI/CD), das Issue Tracking, die Wiki-Funktion und viele mehr. Zusätzlich können Rollen zugewiesen werden, die die Berechtigungen von den jeweiligen Nutzern festlegen.

\mbox{}\\Seit 2013 gibt es zwei Linzenzmodelle von GitLab. Die Community Edition (CE) wird unter der MIT-Lizenz als Open-Source-Software entwickelt und ist auf gitlab.com als Software as a Service (SaaS) erreichbar. Hingegen wird die Enterprise Edition unter einer proprietären Lizenz entwickelt und beinhaltet mehr Funktionen, die für Unternehmen relevanter sind. Bei der EE können Repositories auf einem eigenen Server verwaltet werden.

\section{Hypertext Markup Language}
Hypertext Markup Language, kurz HTML \cite{html_2021}, ist eine Auszeichnungssprache und der Code definiert den Inhalt und die Struktur einer Webseite. Die Strukturierung kann dabei in Paragraphen, Listen, Bildern, Tabellen und einigen anderen Elemente erfolgen. 

\mbox{}\\
\textbf{''Hypertext''} bezeichnet die Links, die entweder auf HTML-Elemente innerhalb einer Webseite verlinkt oder mehrere Webseiten miteinander verbindet. Grundsätzlich werden mithilfe von Links Inhalte in das Internet hochgeladen und mit Seiten verlinkt.\\
\textbf{''Markup''} dient dazu Texte, Bilder sowie weitere Inhalte zur Darstellung in einem Webbrowser zu annotieren.\\
Ein HTML-Element wird in den sogenannten \textbf{''Tags''} auf einer Webseite platziert. Dabei wird der Name des Elementes zwischen die Klammern \texttt{<} und \texttt{>} gegeben. Diese Tags sind case-insensitive, weshalb sie in Groß- oder Kleinbuchstaben oder in einer Mischung dieser geschrieben werden können. Beispielsweise kann ein \texttt{<label>} Tag auch als \texttt{<LABEL>} oder \texttt{<Label>} definiert werden.

\mbox{}\\
Zusätzlich zu HTML kommen andere Technologien wie Cascading Style Sheets, auch CSS, und JavaScript zum Einsatz. Dabei beschreibt CSS das Aussehen der Webseite während JavaScript die Funktionalität und das Verhalten festlegt. 

\subsection{HTML-Elemente}

\paragraph{Aufbau}

\mbox{}\\
Ein HTML-Element ist vorwiegend zusammengesetzt aus einem öffnenden und einem schließenden Tag sowie der Inhalt zwischen diesen Tags. Es ist eine Art Container oder Behälter für die Informationen, die innerhalb von ihm definiert sind.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{images/html-element-example.png}
	\end{center}
		\caption{Beispiel eines HTML-Elementes}
\end{figure}

\begin{itemize}
	\item Das \textbf{öffnende Tag} ist zusammengesetzt aus spitzen Klammern \texttt{< >}, die den Namen des 
		HTML-Elementes 
		umschließen. Es gibt die Stelle an, an der das Element beginnt.
	\item Das \textbf{schließende Tag} ist ähnlich dem öffnenden Tag nur, dass zusätzlich ein Schrägstrich \texttt{/} vor dem
		Namen des HTML-Elementes steht. Es gibt die Stelle an, an der das Element endet. 
	\item Der \textbf{Inhalt} des HTML-Elementes steht zwischen diesen beiden Tags. In der Abbildung handelt es sich hierbei 
		um einen simplen Text.
\end{itemize}

\mbox{}\\
Des Weiteren können HTML-Elemente Attribute beinhalten, die in den spitzen Klammern und nach dem Namen des öffnenden Tags geschrieben werden. Attribute geben Auskunft über zusätzliche Informationen über das Element, der nicht im Inhalt ersichtlich sein soll. Dabei müssen folgende Voraussetzungen erfüllt sein:

\begin{itemize}
	\item Zwischen dem HTML-Elementname und dem Attribut oder mehreren Attributen muss ein Leerzeichen sein.
	\item Nach dem Attributnamen folgt ein Gleichheitszeichen \texttt{=}.
	\item Der Attributwert muss von Anführungszeichen \texttt{"} umschlossen sein.
\end{itemize}

\paragraph{Verschachtelte Elemente}
\mbox{}\\
HTML-Elemente, die sich innerhalb eines Elementes befinden, werden als Verschachtelung bezeichnet. Dabei muss stets darauf geachtet werden, dass die Tags wieder korrekt geschlossen werden. Befindet sich zum Beispiel ein \texttt{<strong>} Tag innerhalb eines \texttt{<p>} Tag, muss darauf geachtet werden, dass der innere Tag vor dem äußeren Tag geschlossen wird. 

\paragraph{Leere Elemente}
\mbox{}\\
Obwohl die meisten HTML-Elemente einen Inhalt haben, gibt es dennoch einige, die keinen besitzen. Dazu zählt beispielsweise der \texttt{<img>} Tag. Bei diesem Element gibt es keinen schließenden Tag und es umhüllt auch keinen Inhalt. Der Zweck hinter
diesen Tags ist es, einzelne Gestaltungselemente einzubinden.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.5]{images/empty-element-example.png}
	\end{center}
		\caption{Beispiel eines leeren HTML-Elementes}
\end{figure}

\mbox{}\\
Damals ist mit Extensible HTML, kurz XHTML am Ende eines leeren HTML-Tags ein Schrägstrich gesetzt worden. Mit HTML5 kann dieser weggelassen werden. 

\subsection{Aufbau eines HTML-Dokumentes}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.7]{images/html-document-structure.png}
	\end{center}
		\caption{Aufbau eines HTML-Dokumentes}
\end{figure}

Die folgenden HTML-Tags bilden zusammen eine HTML-Seite:

\begin{table}[H]
	\begin{center}
	\begin{tabular}{| c | m{10cm} |}
		\hline
 		\cellcolor{Gray}\textcolor{White}{HTML-Element} & \cellcolor{Gray}\textcolor{White}{Beschreibung}  \\
		\hline
		\texttt{<!DOCTYPE html>} & Damals hat dieses Tag dazu gedient, um mit Prüfung von Fehlern und anderen 
			Überprüfungen sicherzustellen, dass die HTML-Seite gut dargestellt wird und funktioniert. Heute dient dieses Tag 
			lediglich dazu, um sicherzugehen, dass das Verhalten des Dokumentes korrekt ist.\\
		\hline
		\texttt{<html></html>} & Diese Element schließt den gesamten Inhalt einer HTML-Seite ein und wird auch als Root-
			Element bezeichnet.\\
		\hline
		\texttt{<head></head>} & Dieses Element ist eine Art Container und umfasst alles, was auf der Webseite beinhaltet, 
			aber nicht für den Betrachter sichtbar sein soll. Dazu zählen zum Beispiel Gestaltungen mit CSS, 
			Zeichensatzdeklarationen und vieles mehr.\\
		\hline
		\texttt{<title></title>} & Damit wird der Titel der Webseite beschrieben, der in der Registerkarte des Browsers angezeigt 
			wird.\\
		\hline
		\texttt{<body></body>} & Dieser HTML-Tag beinhaltet den Inhalt, der für die Benutzer der Webseite angezeigt wird. \\
		\hline
	\end{tabular}
	\end{center}
	\caption{Unterstützte Funktionalitäten der Tastatur}
\end{table}



\section{JavaScript}

\section{TypeScript}

\section{Node.js und npm}

\section{Webpack}