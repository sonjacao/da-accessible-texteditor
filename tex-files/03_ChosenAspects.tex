\chapter{Ausgewählte Aspekte}
\section{WCAG 2.1}
\label{wcag_2_1}
Die Web Content Accessibility Guidelines 2.1 (WCAG 2.1, vgl. \cite{wcag_2_1_2018}) wurden im Dezember 2008 veröffentlicht und sind ein Standard, der weltweit verwendet wird, um Dienstleistungen im Web so barrierefrei wie möglich zu gestalten. Somit können auch Menschen mit Behinderungen, wie etwa Sehschwäche, Blindheit, Hörverlust, Taubheit, körperliche oder kognitive Einschränkung, Sprachbehinderung, Lichtempfindlichkeit, Lernbehinderung oder Kombinationen dieser, das World Wide Web nutzen. Diese Richtlinien sind vom World Wide Web Consortium (W3C, vgl. \cite{w3c_1994}) am 5. Juni 2018 für Webanwendungen empfohlen worden.

Durch die Befolgung der Empfehlungen des W3C können Webdesigner und -entwickler, politische Entscheidungsträger, Käufer, Lehrer und Studenten beziehungsweise Schüler das WWW nahezu problemlos nutzen. Die WCAG 2.1 setzen sich aus allgemeinen Prinzipien, allgemeinen Richtlinien, prüfbaren Erfolgskriterien sowie einer Vielzahl an Techniken zusammen:

\begin{itemize}
	\item Es gibt vier \textbf{Prinzipien}, die die Grundlagen für die Web-Zugänglichkeit bilden: wahrnehmbar, bedienbar, verständlich und robust (englisch: perceivable, operable, understandable and robust).
	\item Die Prinzipien beinhalten insgesamt 13 \textbf{Richtlinien}, an die sich Entwickler halten sollen, um das Web zugänglicher zu machen. Sie sind zwar nicht prüfbar, helfen allerdings dabei die Erfolgskriterien besser zu verstehen und die Techniken besser umzusetzen.
	\item \textbf{Prüfbare Erfolgskriterien} werden dort eingesetzt, wo bestimmte Anforderungen und Tests für die Konformität erforderlich sind, wie etwa beim Entwurf, beim Kauf, bei Regelungen und bei vertraglichen Vereinbarungen. Es gibt drei Ebenen der Konformität, wobei die höchste AAA, die mittlere AA und die niedrigste A ist.
	\item \textbf{Ausreichende und beratende Techniken} dienen zur Erfüllung der Erfolgskriterien und als Beratung. Häufig vorkommende Misserfolge sind ebenfalls dokumentiert.
\end{itemize}

Bei Erreichung der höchsten Ebene ist eine hundertprozentige Web-Zugänglichkeit jedoch nicht garantiert. Die WCAG 2.1 dienen ausschließlich als Anleitung, um das Web so barrierefrei wie möglich zu gestalten. Deshalb wird vom W3C empfohlen sich regelmäßig über den neuesten Stand zu informieren und sich mit anderen zu beraten. Folgende Bemerkung wurde vom W3C (2008, \cite{wcag_2_1_2018}) auf der Webseite veröffentlicht:\\
``[...] Authors are encouraged to consider the full range of techniques [...] as well as to seek relevant advice about current best practice to ensure that Web content is accessible, as far as possible, to this community. [...]``

\section{Web Components}
\label{web_comp}
Web Components (vgl. \cite{moz_webcomp_2019}) sind ein Einheit von Web-Technologien, die dem Benutzer ermöglicht, selbstdefinierte HTML-Elemente zu erstellen und wiederzuverwenden. Diese sind mit ihrem CSS und JavaScript gekapselt und sind somit vollständig von anderem Code getrennt. Mit einigen JavaScript Frameworks wie etwa Angular war es zwar bereits möglich wiederverwendbare HTML-Elemente zu definieren, allerdings nutzt jedes der Frameworks einen anderen Standard. Das bedeutet also, dass der Code in anderen Projekten in den meisten Fällen nicht verwendbar ist. Genau dieses Problem wurde durch Web Components schließlich gelöst. Diese bestehen aus drei Haupttechnologien:

\begin{itemize}
	\item \textbf{Benutzerdefinierte Elemente (engl. Custom Elements):} Ein Satz von JavaScript APIs zur Definition von benutzerdefinierten Elementen.
	\item \textbf{Schatten-DOM (engl. Shadow DOM):} Ein Satz von JavaScript APIs zum Hinzufügen eines DOM-Elementes mit gekapselten Shadow-DOM-Elementen, die für Debugger und Skripte nicht direkt sichtbar sind.
	\item \textbf{HTML-Vorlagen (engl. HTML Templates):} Innerhalb der Elemente \texttt{<template>} und \texttt{<slot>} geschriebene Markup-Vorlagen, die auf der dargestellten Seite nicht abgebildet und als Grundlage für benutzerdefinierte Elemente wiederverwendbar sind.
\end{itemize}

%\subsection{Verwendung in Trix}
%\paragraph{Custom Elements}\mbox{}\\
%Die in Trix benutzerdefinierten HTML-Elemente \texttt{<trix-toolbar>} und \texttt{<trix-editor>} werden mit der Methode \texttt{document.registerElement(tag-name, options)} im DOM neu registriert. Diese Funktion ist allerdings veraltet (vgl. \cite{moz_regel_2019}) und wurde von\\ \texttt{CustomElementRegistry.define()} abgelöst.

%\paragraph{Shadow DOM}\mbox{}\\
%Während des Renderings wird ein \texttt{<div>} HTML-Element um das zu rendernde HTML-Element gewrappt.

%\paragraph{HTML Templates}\mbox{}\\

\section{DOM Manipulation}

% Factory Pattern, Events, Delegate, Observer
\section{Factory Method Pattern}
\subsection{Was sind Design Patterns?}
Um das Factory Method Pattern zu verstehen, muss man zunächst einmal wissen, was ein Design Pattern (dt. Entwurfsmuster) ist. In der Softwareentwicklung treten beim Entwurf oftmals dieselben Probleme auf. Abhilfe hierfür schaffen Design Patterns, die eine allgemeine wiederholbare Lösung dieser Designprobleme sind, den Entwicklungsprozess beschleunigen und programmiersprachenunabhängig sind. Sie repräsentieren somit eine Idee, und keine spezielle Implementierung, durch deren Verwendung der Quellcode für Entwickler flexibler, wiederverwendbar und einfacher zu warten ist. Allerdings sind sie nicht in jedem Projekt zwingend erforderlich, da sie lediglich für die Problemlösung und nicht für die Projektentwicklung gedacht sind.

\paragraph{Arten von Design Patterns}\mbox{}\\

\begin{itemize}
	\item \textbf{Creational Pattern (dt. Erzeugungsmuster):}
	\item \textbf{Structural Pattern (dt. Strukturmuster):}
	\item \textbf{Behavioral Pattern (dt. Verhaltensmuster):}
\end{itemize}

\subsection{Begriffserklärung und Verwendung}
Das Factory Method Patten, auch bekannt als Factory Pattern oder Fabrikmethode, definiert ein Interface oder eine abstrakte Klasse zur Erstellung von Objekten. Die Objekterstellung wird hierbei von den Subklassen übernommen, die entscheiden welche Klasse instanziiert wird. 

\subsection{Vorteile und Nachteile}


\section{JavaScript Events \& EventListener}
\paragraph{trix-initialize}\mbox{}\\
Sobald das Trix-Editor Element im DOM eingefügt wird und sein Editor-Objekt zur Benutzung bereit ist, wird das Event \texttt{trix-initialize} gefeuert.\\
Beim Initialisieren der Toolbar wird auf das von Trix definierte Event \texttt{trix-initialize} gehört. Damit aber nicht die Standard Toolbar sondern die erweiterte Toolbar, die diese ersetzen soll, angezeigt wird, hört bei der Trix-Extension ebenso ein \texttt{EventListener} zu. Sobald das Event gefeuert wird, werden die standardmäßigen Button-Gruppen und Buttons mit denen aus der eigens erstellten Toolbar ersetzt und können mit Screenreadern und Tastaturen barrierefrei bedient werden.

\paragraph{mousedown}\mbox{}\\
Das \texttt{mousedown} Event wird genau zu dem Zeitpunkt gefeuert, an dem sich der Mauszeiger auf einem Element befindet und dieses drückt.\\
Damit ein Button in der Trix-Toolbar aktiv ist und sozusagen ``geklickt`` wird, hört dieser standardmäßig auf ein \texttt{mousedown} Event. In der Erweiterung von Trix wird dieses Event simuliert mit \texttt{EventTarget.dispatchEvent()} und somit sind die Buttons in der Toolbar auch über die Tastatur bedienbar, was vor allem bei Blinden oder bei Benutzern mit einer motorischen Behinderung relevant ist.

\paragraph{keydown}\mbox{}\\
Wenn eine beliebige Taste gedrückt ist, wird das \texttt{keydown} Event gefeuert und liefert einen Code, der aussagt, welche Tasten im Moment gedrückt werden.\\
Um den WYSIWYG Texteditor mittels einer Tastatur bedienen zu können, wurde darauf gewartet bis das \texttt{keydown} Event gefeuert wurde. Je nachdem, welche Taste gedrückt wird, wird entweder der nächste oder der vorherige Button oder die Button-Gruppe fokussiert, geklickt oder der Cursor zur weiteren Texteingabe und Textformatierung in den Editor gesetzt.\\
\\Folgende Tasten und Tastenkombinationen gelten in der Toolbar und im Editor:

\begin{table}[H]
	\begin{center}
	\begin{tabular}{l|p{9cm}l}
		\hline
		\cellcolor{Gray}\textcolor{White}{Taste bzw. Tastenkombination} & \cellcolor{Gray}\textcolor{White}{Beschreibung} \\
		\hline
		\texttt{ALT + F10} & Befindet sich der Cursor im Editor, dann gelangt man mit dieser Tastenkombination in die Toolbar
		und der erste vorkommende Button wird fokussiert.\\
		\hline
		\texttt{→ oder ↓} & Der nächste bzw. rechte Button in der Toolbar wird fokussiert.\\
		\hline
		\texttt{← oder ↑} & Der vorherige bzw. linke Button in der Toolbar wird fokussiert.\\
		\hline
		\texttt{STRG + →/↓} & Der erste Button der nächsten bzw. rechten Gruppe wird fokussiert.\\
		\hline
		\texttt{STRG + ←/↑} & Der erste Button der vorherigen bzw. linken Gruppe wird fokussiert.\\
		\hline
		\texttt{ENTER oder LEERTASTE} & Der aktuell fokussierte Button wird geklickt.\\
		\hline
		\texttt{ESC} & Befindet sich der Fokus in der Toolbar und wird die Taste gedrückt, so wird wieder der Editor fokussiert
		und der Cursor befindet sich an der zuletzt verwendeten Position.\\
		\hline
		\texttt{POS1} & Der erste in der Toolbar vorkommende Button wird fokussiert.\\
		\hline
		\texttt{ENDE} & Der letzte in der Toolbar vorkommende Button wird fokussiert.\\
		\hline
	\end{tabular}
	\end{center}
	\caption{Tastenkombinationen zur Verwendung der Toolbar mit einer Tastatur}
\end{table}

\paragraph{focusout}\mbox{}\\
Sobald ein Element im Begriff dabei ist den Fokus zu verlieren, wird das \texttt{focusout} Event gefeuert.\\
Das Dropdown Menü jedes \texttt{DropdownButtons}~\ref{dropdown_button} erhält beim Initialisieren das Attribut \texttt{hidden}, damit es zu Beginn für den Benutzer nicht sichtbar ist. Sobald der Button geklickt wird, wird auch das Menü sichtbar und der Fokus auf den ersten Button gelegt. Wenn das Menü allerdings nicht mehr fokussiert ist, reagiert der \texttt{EventListener} auf das Event \texttt{focusout} und das Dropdown Menü erhält erneut das Attribut \texttt{hidden} und wird versteckt.

\section{MutationObserver}
Der \texttt{MutationObserver} ist ein Interface, der Veränderungen in der Baumstruktur des DOMs beobachtet und wurde konzipiert, um die Mutation Events aus der DOM3 Events Spezifikation abzulösen.\\
Sobald die Toolbar geladen wird bzw. bestimmte Buttons geklickt werden, werden einige andere Buttons deaktiviert und erhalten das Attribut \texttt{disabled}. Dieses verhindert allerdings das Fokussieren eines Buttons, was mit dem Attribut \texttt{aria-disabled} problemlos funktioniert. Abhilfe verschafft deshalb ein \texttt{MutationObserver}. Erhält ein Button nun das Attribut \texttt{disabled}, beobachtet der \texttt{MutationObserver} diese Veränderung und entfernt es. Stattdessen fügt es das Attribut \texttt{aria-disabled} hinzu und setzt es auf \texttt{true}. Bei allen anderen Buttons, die nicht deaktiviert sind, ist \texttt{aria-disabled=false}.

\section{Delegation}
Die Delegation findet in der objektorientierten Programmierung verschieden Verwendung zur dynamischen Bindung von Methoden zur Programmlaufzeit.\\
Jedem \texttt{AttributeButton} kann die Identifikation eines HTML-Elements mitgegeben werden, das einen Dialog repräsentiert und bereits im HTML-Code erstellt wurde. Die Delegation ermöglicht eine Kommunikation zwischen der Trix-Toolbar und dem Dialog. Sie dient ausschließlich dazu den Dialog zu öffnen und zu schließen, wobei zwei zusätzliche Funktionalitäten das Erstellen und das Entfernen von Links sind. Alles, was während oder nach dem Dialog geschieht, wird vom Entwickler selbst bestimmt.

\section{Barrierefreie Toolbar}
% kurz beschreiben, wie Toolbar accessible wird - was macht eine accessible Toolbar aus/was machen wir
\subsection{Bedienbarkeit \& Navigation}

\subsection{Toolbar Replacer Factory}
% Baut die neue Toolbar

\subsection{Toolbar Replacer}
% Ersetzt die Toolbar

\section{Elemente der Toolbar}
\subsection{Gruppierung der Buttons}

\subsection{Button Elemente}
\label{subsec:buttons}
Es werden vier verschiedene Arten von Buttons unterschieden: 

\begin{itemize}
	\item{\textbf{Action Button}}
	\item{\textbf{Attribute Button}}
	\item{\textbf{Clickable Button}}
	\item{\textbf{Dropdown Button}}
\end{itemize}

\paragraph{Action Button}

\paragraph{Attribute Button}

\paragraph{Clickable Button}

\paragraph{Dropdown Button}
\label{dropdown_button}
